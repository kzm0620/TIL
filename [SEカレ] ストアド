【バッチ処理とは】
　・ある程度のまとまった処理を一括で実行することを指す。
　　ある程度まとまったものを「バッチ」と呼んでいる。

●通常の処理との比較
　・通常の処理はインタラクティブ処理またはリアルタイム処理とよばれる。
　　インタラクティブ処理で時間がかかってしまうとユーザーを待たせてしまうため
　　短時間で終了することが多い。
　　対してバッチ処理はまとまった処理を実行するため時間がかかることが多い。

●バッチ処理のタイミング
　・特定のタイミングで自動実行するケースと、任意のタイミングで実行するケースがある。
　　自動の場合は、実行時間や間隔を定めておく。
　　毎分処理するバッチ処理もできるが、処理に１分以上かかると次の動作に時間が
　　かかってしまうため実行間隔は身長に検討する必要がある。

・クエリを直接発行　mysqlコマンドに続けてクエリを書いてしまう
・自作のプログラムを起動　バッチ処理をプリグラム化し、起動する
・自作のWEBアプリにアクセスする　
　WEBアプリを作成し、アクセスして動作させる

【SQLクエリの基本】
●アドホッククエリ
　プログラムやツール上で記述し、発行しているクエリはアドホッククエリと呼ばれ、
　実行時に毎回データベースサーバが最適化を行っている

　基本的に同じクエリを送っても

●プリペアードステートメント
　最適化処理はコンパイルとよばれる

●オプティマイザ
　実行計画を作成する機能。
　ルールベースオプティマイザと、コストベースオプティマイザがあり、
　近年ではコストベースオプティマイザを利用するのが一般的。
　近年のオプティマイザは優秀なのでWhere句の記述順序などで速度が大きく変わるケースは少ない。
　SQLは後ろから解釈していく

●ルールベース
　SQLの内容と決められたルールによって実行計画を立てる。　
　主キーで

●コストベース

●大量のデータを扱うときなどはクエリの計画を確認する必要がある。
　mysqlではEXPLAINちう命令があり、実行計画を確認することができる。
　さらに詳細な情報をしるためにオプティマイザのトレース情報を所得することもできる


●ストアドプロシージャ
・プログラムで利用するプリペアードステートメントとは違い、
　データベース上でコンパイル済のクエリをあらかじめ準備しておき、
　関数のように呼び出すことができること。これを「ストアドプロシージャ(ストアド)」という。
　ストアドプロシージャは任意に作成することができ、作成はSQLによって行う。

・データベースソフトによって違いはあるが、一般的なデータベースソフトには、
　ストアドプロシージャが実装されている
　mysqlでは「ストアドファンクション」と呼ばれるものがあり、
　プロシージャとファンクションを合わせて「ストアドルーチン」と呼んでいる。


【mysqlのストアドルーチン】

●ストアドプロシージャ
　・他ソフトのストアドプロシージャと同じもの。
　　開発者が作成し、プログラムから呼び出すことが多い。
　　メンテナンス用のストアドプロシージャを作成し、MySQL Workbenchで実行することもある。
　　再帰的に利用することができるため、プログラムの関数に近い感覚で利用することができる。


●ストアドファンクション
　・データベースソフトにあらかじめ用意されているSQL用の関数を開発者が自分で定義できるもの。
　　戻り値があることからファンクションと呼ばれている。
　　プログラムから発行するクエリの中で利用できるが、再帰的な利用はできない。
　　例えばSUM関数を自作できると捉えておけばよい。


【ストアドプロシージャの文法】

●プロシージャの定義は CREATE PROCEDUREで行う。名前は任意のものを付けれる。　
　引数が指定できるため対象のデータの範囲を絞ることもできる
　引数にOUTを指定することで、呼び出し側に値を戻すこともできる

　CREATE PROCEDUR　名前(IN/OUT 引数1 型, IN/OUT 引数2 型)
  BEGIN　
　　実行するプロシージャ
  END;

●SQLの区切り文字「デリミタ」はセミコロン；で区切る
　作成するプロシージャが複数になる場合、プロシージャ内でセミコロンを利用する。
　作成する際は一時的にデリミタを//などに変更することでセミコロンが利用できる。

 DELIMITER   //
 CREATE PROCEDUR .....
 BEGIN 
   SELECT * FROM ～;  ➡ここでセミコロンが使える
   INSERT INTO ～;　　➡ここでセミコロンが使える
 END;
 //

●プロシージャの削除は、DROP PROCEDURE 名前；　で削除できる
　・プロシージャを作成している間は何度も作成と削除を繰り返すことになる。
　　変更する度に上書きするため存在したらDROPしたらCRESTEするという書き方が一般的。
　　区切りはセミコロンに対し、DROPするのは置き換えた後の//にあることに注意。

 DELIMITER   //
 DROP PROCEDURE IF EXISTS 名前// 
 CRESTE PROCEDURE 名前()
 BEGIN ～

●プロシージャの呼び出しには「CALL」を利用する。引数がある場合は指定する。
　OUTパラメータを指定した場合は、値を受け取ることができる
　利用する側では@を付けて変数を渡す。

 CALL 名前('山田',100,@bumon);
 SELECT @bumon;


●ストアドファンクションを作成する場合「CREATE FUNCTION」を利用する。
　戻る値の型を「RETURNS」で指定する
　さらに、ストアドファンクションは「DETERMINISTIC(確定値)」であるかどうかの属性をもつ
　これは与えられた値に対して毎回同じ値が帰るのかを指定する。

　NOT DETERMINISTICなものはデータの値やランダム値を利用するもので、
　引数が同じでも返却値が違うものとなる。

 DELIMITER   //
 DROP PROCEDURE IF EXISTS 名前// 
 CRESTE PROCEDURE 名前(引数　型)
 BEGIN 
   RETURN 処理;
 END
 //


●ストアドプロシージャ内で変数を利用する場合は「DECLARE」で宣言する。
　値を代入するときはSETを使う。

　BEGIN 
    DECLARE 変数名　型；
    SET 変数名 = 'sample';
    SELECT 変数名；
  END

●カーソルとフェッチ
　カーソルとは、データベースの検索結果と「現在の位置」を持つ機能。
　単純に検索結果を配列と捉えるのではなく、連続データと捉えて現在の位置を持つ。

　データを処理していくときは上から順に処理を行っていくケースが多いことから、
　⓵現在位置の行に対する処理
　⓶次の行に移動
　ということを繰り返すのに都合のいい作りだといえる。
　この次の行動に移動することを「フェッチ」と呼ぶ。

●DECLAREによる変数宣言には順序がある。
　⓵単純な偏す
　⓶ハンドラ
　⓷カーソル　　
　この順でないとエラーになるので注意する

●動的なSQLを実行する
　ストアドプロシージャはコンパイル済のクエリを発行できるため、高速に動作するというメリットがある。
　しかし要件によってはどうしても動的にSQLを生成したいときがある。
　例えばデータの内容によって処理対象のカラム名が変わるケースなどではよく発生する。
　SQLのCASE文で対応できることも多いが、状況によっては、
　動的にクエリを生成したほうがシンプルになる。

●動的SQLを実行するために、「PREPARE」コマンドでSQLステートメントを準備する。
　⓵SQLの文字列生成　
　⓶SQLステートメントの生成
　⓷SQLステートメントの実行
　⓸SQLステートメントの開放

　・動的なSQLは単純な変数ではなく、ユーザー定義変数と呼ばれる＠付きのものを利用する。
　　この変数は接続したセッションに対して有効な変数となり、グローバルに宣言したような形になる。

　SET @queryStr := 発行したいクエリ文字列；
  PREPARE stmt FROM @queryStr
  EXECUTE stmt;
  DEALLOCATE PREPARE stmt;

  クエリ文字列の中に可変のパラメータを記述し、
　実行時いUSING　値,値　と指定すれば何度も使いまわすことが可能になる。

