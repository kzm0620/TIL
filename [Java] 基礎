【Javaとは】
●Sun Microsystem社(現Oracle社)が1995年に発表したプログラミング言語の１つ。
●プログラムとは、PCにさせたい処理の順番を書き記したもの。
　「ソースプログラム」や「ソース」とも呼ぶ。

【Java特徴】
●オブジェクト指向➡大規模な開発が可能
●プラットフォーム非依存➡1度作ったものはどこでも動く
●JVM(Java virtual Machine)Javaのプログラムを動かすためのソフトウェア➡Java仮想マシンとも呼ばれる
●JDK(Jva Dvelopment Kit)Javaの開発環境、Oracle社のサイトからダウンロードできる

【Javaの動かす準備】
⓵JDKのインストール➡Adapt Open JDKを利用(インストール時に環境変数を自動で設定してくれる)
⓶環境変数の設定(Windouwsに対して行う設定)
・PATH　　　　Javaの実行ファイルはどこ？➡JDK内の「bin」フォルダの場所を指定
・JAVA_HOME　 Javaはどこ？➡JDKのフォルダの場所を指定
(⓷コマンドプロンプトで設定確認)

【Java開発の流れ】
⓵ソースプログラムの作成
　➡ファイル名は「---.java」
⓶コンパイル
　➡コマンドプロンプトで「javac ソースファイル名」➡「---.class」が生成される
⓷実行
　➡「java クラス名」

【Eclipseとは】
●無料せ高機能な「IDE」の１つ (integrate development Enviroment)
　➡プログラム開発に必要なエディタやコンパイラ、デバッガなどをまとめた「統合化初環境」。
　➡JVM(実行開発環境)➡JDK(コンパイラ、クラスなど)➡IDE(エディタ、コンソールなど)
　　他にVSCode, IntelliJ, IDEAなど

【Eclipseを使うメリット】
⓵「無料」で使えるオープンソース
⓶「高機能」で安定して動く
　➡コンテンツアシスト、即時修正機能　など
⓷「プラグイン」でさらに機能拡張
　・Pleiades：日本語化
　・WTP：WEB開発ツール
　➡「Pleiades　All in One」をインストール！

【Eclipse設定＆便利機能】
●環境設定
　⓵パースペクティブ　(エディタなどのウインドウを組み合わせた画面構図)
　⓶外観
　⓷テキストエディタ
　⓸色とフォント
●プログラミング
　⓹gettar/setterの自動生成
　⓺フォーマット　　　　 （Ctrl + Shift + F）インデントを行ってくれる
　⓻コンテンツアシスト　　(Ctrl + Shift + F）(や{などを入力すと自動で相方も出してくれる
　⓼テンプレート　　　　　(Ctrl + Shift + F）
　⓽タグジャンプ　　　　　(Ctrl + 右クリック）
　⓾インポートの生成　　　(Ctrl + Shift + O）
●実行・デバッグ
 11 即時修正　　　　　　　(Ctrl + l）
 12 コメントアウト　　　　(Ctrl + / (+Shift)）
 13 デバッグ機能　　　　　(F5,F6,F7,F8）
●保守
 14 リファクタリング
 15 Javadogの生成

-----------------------------------------------------------------

【Javaプログラムの構成】
●Javaのプログラムはの「クラス」の集まり
●クラス名と「ファイル名は合わせる
●クラスの内容を{から}の間(ブロック)に書く
●処理のまとまりを「メソッド」と呼び、Javaは「mainメソッド」から実行される
●処理文は「;セミコロン」で終わる

【分かりやすプログラムを書く3つのポイント】
⓵「コメント」：プログラム内のメモ書きを残すこと
　・// コメント　➡1行のコメント
　・/* コメント　➡複数行のコメント
⓶「フォーマット」：プログラムの体裁を整える
　・ブロックの開始、終了や処理文ごとに「改行」する
　・タブや半角スペースで「字下げ(インデント)」する
⓷「命名ルール」：名付けの慣習
　・１文字目
　　クラス・インターフェース：「大文字」
　　変数・メソッド、パッケージ：「小文字」
　・２つ目以降の単語は「大文字」から

【変数】
●変数とはデーの「入れ物」
●変数名のルール
・1文字目　英字(a-z, A-Z) _ $
・2文字目以降は数字も可
・キーワードは使えない(static,public,voidなど)

【変数の使い方】
⓵「宣言」する：変数を作る ➡ データ型、変数名、変数名....;）(int age;)
⓶「代入」する：値を入れ る➡ 変数名＝値;　（age=20;)
⓷「参照」する ➡ (int age=20;)
⓵＋⓶「初期化」する ➡ (int age = 20;)

【データ型】
⓵基本データ型
⓶参照型

【データ型：データの種類】
　⓵基本データ型
　　・整数    byte     8ビット   128---127                  小
             short    16ビット  32.768---32.767  　　　　　　
             int      32ビット  2147483648---2147483647
             long     64ビット  9223372037988...........
　　・小数    floot    32ビット  4バイト単制度、浮動小数点数
             double   64ビット  8aバイト倍制度、浮動小数点数　大
　　・文字    char     16ビット　1文字(Unicode)
　　・真偽値  boolean  ------    true または false
　⓶参照型
　　・文字列
　　・配列
    .......

●数値はデフォルトで「int」と「double」
　➡floot型の小数にはf(F)を、long型の整数にはl(L)をつける
●文字のデータは「'」で囲む

⓶参照型(文字列：String)　➡　String name = "佐藤";
　・データ自体はメモリ上の別の場所に置かれてそのアドレスの値「参照値」が変数に入る

【配列】
●「配列」は同じデータ型の変数を複数まとめて管理するもの
●配列の生成には「new」を使う。生成時にデフォフォルト初期値が設定される(0,'',false)
　➡データ型 [] 配列名 = new データ型[要素数];
    int [] score = new int[3];
    score [0] = 80;  (添字([]内の数字)は０から)
●配列の初期化
　➡データ型 [] 配列名 = [値１、値２,....]
●配列名.lingthで配列の「要素数」を取得できる

【多次元配列】
●配列配列を作れる
　int[][] allScore = new int[2][3]; (2行3列の多次元配列)
  all Score
    all Score[0]　→　80 100 75
    all Score[1]　→  85 95 80
    all Score.length
    all Score[0].length

【コマンドラインからのデータ入力】
●javaコマンド実行時にプログラムにデータを渡せる

【基本データ型の型変換】
●数値同士の演算や代入をするときにデータ型の変換が、、、
　・「自動」で行われる➡表現できる値の幅が　小→大　(大は小を兼ねるの概念)
　・「キャスト」で明示する➡表現できる値の幅　大→小 (大から小に入るのか？的な理由で)
     キャストは()内に変換後のデータ型の名前を書く

  小 byte
  　 short(char)     int i:      i[32]
  　 int             double d:   d[64] 
  　 long            d = i;
  　 float           i = (int)d; ← キャストが必要(変換後の型)
  大 double

　・計算結果の小数点以下を切り捨てて整数にしたいときに(int)をつける

【構造化プログラミング】
⓵順次進行
⓶分岐
⓷繰り返し

【if文】
if (条件式) {
   処理１
} else {
 　処理２
}
●どちらの処理しか実行されない
●slse以降は省略できる
●処理が１つのときは{}を省略可(分かりずらくなるので推奨はしない)

--------------------------------------------------------------------

【オブジェクト指向】
●「実行用」クラスと「設計図」クラスがある
●「オブジェクト」：クラスから作られる実態(モノ)
●「オブジェクト指向」：オブジェクトを中心にしてプログラムを作る考え方のこと
　➡持っているデータや処理を分けてクラスを組み合わせて動かしていく
　➡クラスごとに分担して作業ができるので作業効率も良い
　➡大規模開発もしやすくなり、後のメンテナンスもしやすい

【クラス(設計図)】
●属性➡変数(何のデータを持っているか)
●操作➡メソッド(何の処理をできるか)

【２種類のクラス】
●実行用クラス：「メインメソッド」を記述
●設計図クラス：「属性」と「操作」を記述
●変数の定義
　データ型　変数名;
　例) String name;
        int score;

【メソッドの定義】
●戻り値の型　メソッド名(引数リスト) {
　　処理
 }
●「引数」：呼び出し元から受け取る値
●「戻り値」：メソッドの処理の後に呼び出し元に返す値「return」で指定する。
　何も返さない場合は戻り値の型に「void」を記述する。

【オブジェクトの使い方】
●生成
　・クラス名　オブジェクト名 = new クラス名();
  例 Student    stul       = new Student();
●変数、メソッドを利用
　・オブジェクト名.変数名　➡　stul.name = "佐藤";
　・オブジェト名.メソッド名(引数)　➡　stul.setScore(80,90);

【オーバーロード】
●クラス内に同じ名前で引数の型や数が違うメソッドを複数定義することを「オーバーロード」
●呼び出すメソッドは「名前」と「引数」の組み合わせで決めている

【コンストラクタ】
●オブジェクトの初期化のために使われ特殊なメソッドを「コンストラクタ」と呼ぶ
●コンストラクトとは組み立てる、作成するなどの意味
●オブジェクトの生成と値の代入を同時にできる
　ルール⓵　名前が「クラス名」と同じ
　ルール⓶　「戻り値」を持たない
　ルール⓷　newクラス名(コンストラクタへの引数)
●コンストラクタを定義していない場合は自分で
「デフォルトコンストラクタ(引数、処理なし)」がコンパイル時に自動で生成される
　例　Student(){}

【作った変数の個数を知る方法は？】
class Student {
　　int counter ＝ 0； (作成したインスタンスを数えるカウンター)
  Student() {
    counter ++:
  }
}
➡０から１に代わるという処理がが続くだけ
➡インスタンス内の変数では「無理」
　全インスタンスが「共通」して使える変数が必要
➡インスタンス外で全部が共通して使えるカウンター(変数)があればよい
　そこで使われるのが「static」

【static変数、staticメソッド】
●全インスタンス変数が使えるメンバ変数やメソッドを定義するには「static」を指定する
●オブジェクトを「生成」しなくても利用できる
　➡クラス名.変数[メソッド]名　と記述
●クラスの関連する便利なメソッドをまとめたい時にも使われる


【カプセル化】
●「アクセス修飾子」でクラス・メンバ変数・メソッドの公開範囲を指定できる

修飾子　　　同クラス　同パッケージ　サブクラス　他
public　　　 〇　　　　　〇　　　　　　〇　　　〇
protected　　〇　　　　　〇　　　　　　〇
(なし)　　　　〇　　　　　〇
private　　　〇

●この表は上に行けば行くほど公開範囲が広がる
●メンバ変数は隠蔽(private)して、クラスとメソッドは公開(public)する設計方針を
　「カプセル化」と呼ぶ ➡ [代入前処理]、[修正範囲が狭まる]

---------------------------------------------------------------------------

【継承】
●「継承」とは既存のクラスをもとに変数やメソッドを作ること
●継承関係にある親のクラス「スーパークラス」、子のクラスを「サブクラス」をいう
　➡[コーデング]、[メンテナンス]が楽になる
　・継承するクラスは「１つ」だけ
　・「コンストラクタ」は継承しない　

【オーバーライド】
●サブクラスでスーパークラスのメソッドを再定義(上書き)することを指す
　➡「戻り値の型」「メソッド名」「引数の型と数」がすべて同じであることが条件

【thisとsuperによるメンバ変数・メソッドの呼び出し】
●this.  ～ = 自分のオブジェクの～
●super. ～ = スーパークラスの～
　➡[同じコードを書かなくても良い]、[引数名を考えなくて良い]

class Person {
  String name:
  void setName(String,name) {
    this.name = name;
  }
  void display() {....}　.......⓶ ⓵から⓶を呼び出す
}

class Student extends Person {
  int stuNo:
    void display() {       ......⓵←Student stu = new student() : 
       super.dispaly();               stu.display();
       System.out.println(stuNo);
    }
}

【thisとsuperによるコンストラクタの呼び出し】
●[this.(引数), super(引数)]
　➡キーワードの後にすぐ()を書くとコンストラクタを呼び出すことができる
●this()は同じクラスの中でコンストラクタを呼び出し合うことができる
●suoer()はスーパークラスのコンストラクタを呼び出すことができる
※this(),super()はコンストラクタ内の先頭に記述する
　(なければ自動的にsuper()が挿入される)

【final キーワード】
●クラスやメソッドに付けられる修飾子で「これが最後」という意味
　・クラス　➡　これ以上「継承」ができなくなる
　・メンバ変数　➡「代入」ができなくなる。「定数を作れる」(定数名は全て大文字)
　・メソッド　➡「オーバーライド」ができなくなる

【参照型の型変換】
●継承関係にあるクラス同士でオブジェクトの型変換が、
　・サブ➡スーパー　のときは「自動」で行われる
　・スーパー➡サブ　のときは「キャストで明示する」
Student stu１ ＝ new Student(-);
Person psn = stu1;　(ここで参照型の型変換が自動で行われている)
Student stu2 = (Student) psn;　(キャストの記述で実行するとstu2の変数ができて値もコピーされる)
psn display(); ➡　オーバーライドに有効
psn chgStuNo(-): ➡　コンパイルエラー
stu2.chgStuNo(-); ➡　呼び出しできる

【２種類の継承】
⓵機能追加

⓶共通

