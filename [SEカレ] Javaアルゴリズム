００１
両社が等しくなるまで繰り返す　until
↓
両社が等しくない限り返す　　　while
---------------------------------------
００２
整数aが素数かどうかを判定するアルゴリズム
2～√aまでの全ての整数で割ってみる
int max = (int)Math.aqrt(a);
2～maxまでのすべての整数で割ってみる
割り切れる数が見つかったら素数ではない、
見つからなければ素数である。
------------------------------------------
００３
整数yearがうるう年かどうか判定するアルゴリズム
西暦yearが4で割り切れ、かつ、100で割り切れないなら、うるう年である。
ただし、yearが400で割り切れたら、うるう年である。
それにも該当しないなら、うるう年でない。
------------------------------------------
００４
配列の合計値を求めるアルゴリズム
合計値を格納する変数に０を代入しておく。
for文で配列の要素を先頭から末尾まで１つずつ取り出し、変数sumに集計する。
--------------------------------------------
００５
配列の最大値を求めるアルゴリズム
最大値を格納する変数maxに配列に先頭の要素の値を代入しておく。
for文で配列の要素を先頭の１個先から末尾まで１つずつ取り出し、
取り出した値がmaxより大きかったら、その末尾でmaxを更新する。
繰り返しを抜けたときmaxが最大値として確定する。
-----------------------------------------------
００６　バブルソート（交換法）のアルゴリズム
外側の繰り返し　何番目を決定するか　ｎ
　内側の繰り返し　比較位置　　　　　　p
　a[p -1 ] > a[p] なら、両者の値を交換する。
値を交換するときに一時的に値を逃がさないといけないので、
tmp(temporary)を使用する。
---------------------------------------------------－
００７　セレクションソート（選択法）のアルゴリズム
小さい順にソートする
外側の繰り返し　何番目の位置を確定するか　変数n＝０～３　｛
　　ａ[ｎ]を仮の最小値とする　
　　内側の繰り返し　チェックする位置　変数ｐ＝n＋１～４　｛
　　　　もしも仮の最小値　＞　a[p]なら、仮の最小値をa[p]で更新
　　｝
　　a[n]と最小値の要素の値を交換
｝
-------------------------------------------------------
００８　挿入法のアルゴリズム
外側の繰り返し　何番目の要素を挿入するか　ｎー１～末尾　｛
　　挿入する値を別の変数に逃がしておく
　　内側に繰り返し　挿入する要素と比較する要素の位置　ｐ＝ｎー１～０　｛
　　　a[p]が挿入する値より大きいなら、a[p]の値を１つ後に移動する
　　｝
　　逃がしておいた値を挿入位置に入れる
｝
-------------------------------------------------------
００９　線形探索のアリゴリズム
配列の先頭から末尾に向かって、要素を一つずつXと同じ値かどうか
チェックすることを繰り返す。
見つかったらその時点で繰り返しを終了して、その位置を返す。
-------------------------------------------------------
０１０　二分探索のアルゴリズム
ソート済の場合は真ん中からチェックする。求める値がありそうな値の真ん中を探索、を繰り返す。
Leftに配列の左橋の要素番号、Rightに配列の右端の要素番号を入れる。
while left <= right {
  mid = (left + rigth) / 2
    もしもa[mid] == x なら見つかった処理をする。
　　　そうでなくて、a[mid] < x なら真ん中より後ろ側に探索対象を絞り込む
　　　そうでない場合（a[mid] > x）なら真名kより前後に探索対象を絞り込む
｝
探索結果を返す
-------------------------------------------------------
０１１　再帰呼び出し(recursive call)
メソッドの処理の中で、同じメソッドを呼びだすことで、
繰り返しを実現するプログラミングテクニック。
メソッドを呼び出すと、メソッドの先頭から処理が行われるので、当然繰り返しになる。

void myMethod(...) {
  処理
　myMethod(...)
}
階乗　5! = 5 x 4 x 3 x 2 x 1 = 5 x 4! = 120
      getFctorial(5) {
        5 * getFctorial(4)
      }
再帰呼び出しで階乗を求めるアルゴリズム
もしも引数ｎが０なら、再帰呼び出しをせずに１を返す。
そうでないなら、n * getFctorial(n-1)を返す。
